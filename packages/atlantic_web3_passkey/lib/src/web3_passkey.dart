
import 'dart:convert';
import 'dart:core';
import 'dart:typed_data';

import 'package:atlantic_web3/atlantic_web3.dart';
import 'package:atlantic_web3_passkey/atlantic_web3_passkey.dart';
import 'package:encrypt/encrypt.dart';
import 'package:pointycastle/export.dart';

import 'bip39/keystore.dart';


class Web3Passkey implements IWeb3Passkey {
  // Instancia privada
  static Web3Passkey? _instance = null;

  static IWeb3Passkey instance() {
    if (_instance == null) {
      _instance = Web3Passkey._();
    }
    return _instance!;
  }
  late final EthBip39Generator _bip39;
  late final EthPassKeyStore _keyStore;

  Web3Passkey._() {
    _bip39 = EthBip39Generator();
    _keyStore = EthPassKeyStore();
  }

  /// Permite generar frases mnemonic dependiendo el lenguaje y longitud, tambien
  /// debe tomar en cuenta el id del dispositivo para usarlo como una entropy inicial
  /// para que sea de manera unica y aleatoria. La longitud de la frases se de determina
  /// por la siguiente tabla:
  ///
  /// ---------------------------------
  /// | words length | entropy length |
  /// ---------------------------------
  /// | 12           | 128            |
  /// | 15           | 160            |
  /// | 18           | 192            |
  /// | 21           | 224            |
  /// | 24           | 256            |
  /// ---------------------------------
  /// mas informacion <a href="https://github.com/leonardocustodio/polkadart/blob/main/packages/substrate_bip39/lib/crypto_scheme.dart">aqui</a>
  ///
  @override
  Mnemonic generateMnemonic({int length = 12, Language language = Language.english}) {
    if ([12,15,18,21,24].contains(length) == false) {
      throw ArgumentError('The words length must be 12, 15, 18, 21 or 24', length as String?);
    }

    final List<String> words = _bip39.generateWordsRandomly(length, language);

    return Mnemonic.from(words);
  }

  @override
  EthPassKey createEthPassKey(IMnemonic mnemonic, String passphrase) {
    // Semilla
    final Uint8List seed = Pbkdf2.createSeedFromMnemonicAndPassword(mnemonic, passphrase);

    // BIP39: A checksum is generated by taking the first bits of its SHA256 hash.
    final sha256 = SHA256Digest();
    final key = sha256.process(seed);

    // Encapsular claves publica y privada
    final ECKeyPair keyPair = ECKeyPair.create(key);

    // Crear llave de accesos usando las claves
    return EthPassKey.fromKeyPair(keyPair);
  }

  @override
  EthBip32PassKey createDerivateEthPassKey(IMnemonic mnemonic, String passphrase) {
    // Semilla
    final Uint8List seed = Pbkdf2.createSeedFromMnemonicAndPassword(mnemonic, passphrase);

    // BIP39: A checksum is generated by taking the first bits of its SHA256 hash.
    final sha256 = SHA256Digest();
    final key = sha256.process(seed);

    // Encapsular claves publica y privada
    final ECKeyPair keyPair = ECKeyPair.create(key);

    // Crear derivador de llaves de accesos usando las claves
    return EthBip32PassKey.fromKeyPair(keyPair);
  }

  @override
  Future<EthPassKey> saveEthPasskey(String documentId, String name, EthPassKey passKey, String passPhrase) async {
    final AES algorithm = AES(Key.fromUtf8(passPhrase));

    final Encrypted encName = algorithm.encrypt(utf8.encode(name));
    final Encrypted encPrivateKey = algorithm.encrypt(utf8.encode(passKey.keyPair.privateKey.toString()));
    final Encrypted encPublicKey = algorithm.encrypt(utf8.encode(passKey.keyPair.publicKey.toString()));

    final model = EthPassKeyModel(
        documentId,
        true,
        DateTime.now(),
        DateTime.now(),
        encName.toString(),
        encPrivateKey.toString(),
        encPublicKey.toString(),
        false,
        null);

    final EthPassKeyModel result = await _keyStore.create(model);

    final decName = utf8.decode(algorithm.decrypt(Encrypted.fromUtf8(result.name)));
    final decPrivateKey = utf8.decode(algorithm.decrypt(Encrypted.fromUtf8(result.privateKey)));
    final decPublicKey = utf8.decode(algorithm.decrypt(Encrypted.fromUtf8(result.publicKey)));

    // Encapsular claves publica y privada
    final ECKeyPair keyPair = ECKeyPair.fromKeyPairString(decPrivateKey, decPublicKey);

    // Crear derivador de llaves de accesos usando las claves
    return EthPassKey.fromKeyPairExtender(keyPair, documentId, decName, null);
  }

  @override
  Future<EthPassKey> setDefaultEthPasskey(String passKeyID, String passPhrase) async {
    final Integer exist = await _keyStore.existDefault(passKeyID);

    if (exist == 0) {
      throw Exception('No exist default');
    } else {
      final List<EthPassKeyModel> list = await _keyStore.find();

      for (final element in list) {
        if (element.passkeyID == passKeyID) {
          element.isDefault = true;
        } else {
          element.isDefault = false;
        }
        await _keyStore.update(element);
      }

    }

    // Reusar
    return getDefaultEthPasskey(passPhrase);
  }

  @override
  Future<EthPassKey> getDefaultEthPasskey(String passPhrase) async {
    final AES algorithm = AES(Key.fromUtf8(passPhrase));

    final EthPassKeyModel result = await _keyStore.findDefault();

    final decName = utf8.decode(algorithm.decrypt(Encrypted.fromUtf8(result.name)));
    final decPrivateKey = utf8.decode(algorithm.decrypt(Encrypted.fromUtf8(result.privateKey)));
    final decPublicKey = utf8.decode(algorithm.decrypt(Encrypted.fromUtf8(result.publicKey)));

    // Encapsular claves publica y privada
    final ECKeyPair keyPair = ECKeyPair.fromKeyPairString(decPrivateKey, decPublicKey);

    // Crear derivador de llaves de accesos usando las claves
    return EthPassKey.fromKeyPairExtender(keyPair, result.passkeyID, decName, null);
  }

  @override
  Future<EthPassKey> getEthPasskey(String passkeyID, String passPhrase) async {
    final AES algorithm = AES(Key.fromUtf8(passPhrase));

    final EthPassKeyModel result = await _keyStore.findOne(passkeyID);

    final decName = utf8.decode(algorithm.decrypt(Encrypted.fromUtf8(result.name)));
    final decPrivateKey = utf8.decode(algorithm.decrypt(Encrypted.fromUtf8(result.privateKey)));
    final decPublicKey = utf8.decode(algorithm.decrypt(Encrypted.fromUtf8(result.publicKey)));

    // Encapsular claves publica y privada
    final ECKeyPair keyPair = ECKeyPair.fromKeyPairString(decPrivateKey, decPublicKey);

    // Crear derivador de llaves de accesos usando las claves
    return EthPassKey.fromKeyPairExtender(keyPair, result.passkeyID, decName, null);
  }

  @override
  Future<List<EthPassKey>> getAllEthPasskey(String passPhrase) async {
    final AES algorithm = AES(Key.fromUtf8(passPhrase));

    final List<EthPassKeyModel> result = await _keyStore.find();

    final List<EthPassKey> list = result.map((element) {

      final decName = utf8.decode(algorithm.decrypt(Encrypted.fromUtf8(element.name)));
      final decPrivateKey = utf8.decode(algorithm.decrypt(Encrypted.fromUtf8(element.privateKey)));
      final decPublicKey = utf8.decode(algorithm.decrypt(Encrypted.fromUtf8(element.publicKey)));

      // Encapsular claves publica y privada
      final ECKeyPair keyPair = ECKeyPair.fromKeyPairString(decPrivateKey, decPublicKey);

      // Crear derivador de llaves de accesos usando las claves
      return EthPassKey.fromKeyPairExtender(keyPair, element.passkeyID, decName, null);
    }).toList();

    return list;
  }

}
